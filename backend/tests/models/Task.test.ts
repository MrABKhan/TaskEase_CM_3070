import mongoose from 'mongoose';
import Task from '../../models/Task';
import { mockTask } from '../mocks/mockData';

// Mock the Task model
jest.mock('../../models/Task');

describe('Task Model', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  it('should create a new task successfully', async () => {
    const taskData = { ...mockTask };
    delete taskData._id; // Remove _id as it will be generated by MongoDB
    
    // Mock the save method
    const mockSave = jest.fn().mockResolvedValue({
      ...taskData,
      _id: new mongoose.Types.ObjectId().toString(),
    });
    
    // Mock the Task constructor
    (Task as unknown as jest.Mock).mockImplementation(() => ({
      save: mockSave,
    }));
    
    const task = new Task(taskData);
    const savedTask = await task.save();
    
    expect(savedTask._id).toBeDefined();
    expect(savedTask.title).toBe(mockTask.title);
    expect(savedTask.description).toBe(mockTask.description);
    expect(savedTask.category).toBe(mockTask.category);
    expect(savedTask.priority).toBe(mockTask.priority);
    expect(savedTask.startTime).toBe(mockTask.startTime);
    expect(savedTask.endTime).toBe(mockTask.endTime);
    expect(savedTask.date).toEqual(mockTask.date);
    expect(savedTask.completed).toBe(mockTask.completed);
    expect(savedTask.notes).toEqual(mockTask.notes);
    expect(savedTask.subtasks.length).toBe(mockTask.subtasks.length);
    expect(savedTask.tags).toEqual(mockTask.tags);
    expect(savedTask.userId).toBe(mockTask.userId);
    expect(mockSave).toHaveBeenCalled();
  });

  it('should fail to create a task without required fields', async () => {
    // Mock validation error
    const mockSave = jest.fn().mockRejectedValue(
      new mongoose.Error.ValidationError()
    );
    
    // Mock the Task constructor
    (Task as unknown as jest.Mock).mockImplementation(() => ({
      save: mockSave,
    }));
    
    const task = new Task({
      title: 'Incomplete Task',
      // Missing other required fields
    });
    
    let error;
    try {
      await task.save();
    } catch (err) {
      error = err;
    }
    
    expect(error).toBeDefined();
    expect(error).toBeInstanceOf(mongoose.Error.ValidationError);
    expect(mockSave).toHaveBeenCalled();
  });

  it('should find tasks by userId', async () => {
    // Mock Task.find
    (Task.find as jest.Mock).mockResolvedValue([mockTask]);
    
    const foundTasks = await Task.find({ userId: mockTask.userId });
    
    expect(foundTasks.length).toBeGreaterThan(0);
    expect(foundTasks[0].title).toBe(mockTask.title);
    expect(foundTasks[0].userId).toBe(mockTask.userId);
    expect(Task.find).toHaveBeenCalledWith({ userId: mockTask.userId });
  });

  it('should update a task', async () => {
    const updatedTitle = 'Updated Task Title';
    const updatedTask = { ...mockTask, title: updatedTitle };
    
    // Mock Task.findByIdAndUpdate
    (Task.findByIdAndUpdate as jest.Mock).mockResolvedValue(updatedTask);
    
    const result = await Task.findByIdAndUpdate(
      mockTask._id,
      { title: updatedTitle },
      { new: true }
    );
    
    expect(result).toBeDefined();
    expect(result?.title).toBe(updatedTitle);
    expect(Task.findByIdAndUpdate).toHaveBeenCalledWith(
      mockTask._id,
      { title: updatedTitle },
      { new: true }
    );
  });

  it('should delete a task', async () => {
    // Mock Task.findByIdAndDelete
    (Task.findByIdAndDelete as jest.Mock).mockResolvedValue(mockTask);
    
    // Mock Task.findById to return null after deletion
    (Task.findById as jest.Mock).mockResolvedValue(null);
    
    await Task.findByIdAndDelete(mockTask._id);
    
    const deletedTask = await Task.findById(mockTask._id);
    
    expect(deletedTask).toBeNull();
    expect(Task.findByIdAndDelete).toHaveBeenCalledWith(mockTask._id);
    expect(Task.findById).toHaveBeenCalledWith(mockTask._id);
  });
}); 